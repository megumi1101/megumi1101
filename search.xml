<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树的直径相关问题</title>
      <link href="/2024/10/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/11/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋树的直径相关问题fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋树的直径相关问题fontcenter"></a> <center><font color="red" font face="仿宋">树的直径相关问题</font></center></h1><h2 id="求树的直径"><a class="markdownIt-Anchor" href="#求树的直径"></a> 求树的直径</h2><ol><li>两边dfs<br />首先从任意节点 y 开始进行第一次 DFS，到达距离其最远的节点，记为 z，然后再从 z 开始做第二次 DFS，到达距离 z 最远的节点，记为 z’，则 dis(z,z’) 即为树的直径。<br /><em>上述证明过程建立在所有路径均不为负的前提下。如果树上存在负权边，则上述证明不成立。故若存在负权边，则无法使用两次 DFS 的方式求解直径。</em></li></ol><h2 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h2><ol><li><em><strong>无权树上任意一个节点，与它距离最远的节点一定是直径的某个端点.</strong></em></li></ol><h2 id="codechef-diameter-of-tree"><a class="markdownIt-Anchor" href="#codechef-diameter-of-tree"></a> <a href="https://www.codechef.com/problems/DTREE">CodeChef, Diameter of Tree</a></h2><p>题干<br /><em><strong>求一颗n个节点树删除一个点的直径(删除一个节点后如果变成两个数,求两棵树直径的最大值),输出n次(即是每个点都删除一次)</strong></em><br />解法<br />先找出树的直径,如果删除的点不在直径上,则输出直径.<br />维护三个数组;<br />d1[u] u到子树内叶子节点的最远距离;<br />d2[u] u到子树内叶子节点的直径;<br />d3[u] u的子树内的直径;<br />如果当前删除的节点是在直径上的节点u;<br />那么我们的答案就是 d3[u] 和 它的父亲上方的直径 中的最大值.<br />由于 u 节点 一定在 直径上.<br />假设直径的两个端点分别是 s1,s2;<br />那么我们分别以s1,s2为根dfs 维护d1,d2,d3.<br />所以答案就是两次dfs中d3[u]的最大值.(因为第一次dfs中父亲上方的直径会成为第二次dfs中的d3)<br />我们可以在两次dfs中将d1,d2清零,d3不清零.<br />代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    void main();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    xbbbz::main();return 0;</span><br><span class="line">&#125;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    #define IOSFAST ios::sync_with_stdio(false),cin.tie(0);</span><br><span class="line">    #define int long long</span><br><span class="line">    const int N=1e5+10;</span><br><span class="line">    vector&lt;int&gt;ed[N];</span><br><span class="line">    int n,c;</span><br><span class="line">    int fa[N],dep[N];</span><br><span class="line">    int d1[N],d2[N],d3[N];</span><br><span class="line">    bool vis[N];</span><br><span class="line">    void dfs1(int u,int f)&#123;</span><br><span class="line">        dep[u]=dep[f]+1;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        if(dep[u]&gt;dep[c])c=u;</span><br><span class="line">        for(int v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int f)&#123;</span><br><span class="line">        d1[u]=d2[u]=0;</span><br><span class="line">        int max1=0,max2=0;</span><br><span class="line">        for(int v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs2(v,u);</span><br><span class="line">            d1[u]=max(d1[v]+1,d1[u]);</span><br><span class="line">            d2[u]=max(d2[v],d2[u]);</span><br><span class="line">            d3[u]=max(d3[u],d2[v]);</span><br><span class="line">            if(d1[v]+1&gt;max1)&#123;</span><br><span class="line">                max2=max1;</span><br><span class="line">                max1=d1[v]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(d1[v]+1&gt;max2)&#123;</span><br><span class="line">                max2=d1[v]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d2[u]=max(d2[u],max1+max2);</span><br><span class="line">    &#125;</span><br><span class="line">    void sol()&#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)ed[i].clear();</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            ed[u].push_back(v),ed[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        int s1,s2;</span><br><span class="line">        memset(dep,0,sizeof(dep));dfs1(1,0);s1=c;</span><br><span class="line">        memset(dep,0,sizeof(dep));dfs1(s1,0);s2=c;</span><br><span class="line">        int len=-1;</span><br><span class="line">        for(int i=s2;i;i=fa[i])&#123;</span><br><span class="line">            len++;vis[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(d3,0,sizeof(d3));</span><br><span class="line">        dfs2(s1,0);dfs2(s2,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(!vis[i])cout&lt;&lt;len&lt;&lt;&quot; &quot;;</span><br><span class="line">            else cout&lt;&lt;d3[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    void main()&#123;</span><br><span class="line">        IOSFAST;</span><br><span class="line">        int T;cin&gt;&gt;T;</span><br><span class="line">        while(T--)&#123;</span><br><span class="line">            sol();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cf911f-tree-destruction"><a class="markdownIt-Anchor" href="#cf911f-tree-destruction"></a> <a href="https://codeforces.com/problemset/problem/911/F">CF911F Tree Destruction</a></h2><p>题干<br /><em><strong>给你一棵 n 个结点组成的树，你需要对树进行 n−1 次操作，一次操作包含如下的步骤：</strong></em><br /><em><strong>1.选择两个叶子结点</strong></em><br /><em><strong>2.将这两个结点之间简单路径的长度加到答案中</strong></em><br /><em><strong>3.从树上删去两个叶子结点之一</strong></em><br /><em><strong>初始答案为 0</strong></em><br /><em><strong>显然在 n−1 次操作之后树上只剩下一个结点。</strong></em><br /><em><strong>计算最大的答案，并构造一组操作序列。</strong></em><br />题解<br />我们需要最大化删掉的叶子节点的贡献。<br />由于无权树上任意一个节点，与它距离最远的节点一定是直径的某个端点，所以把直径的端点求出来，然后对于每个不在直径上的叶子节点，判断哪个端点与它距离较远，加上贡献即可。<br />最后删到只剩直径时，就一个一个删即可。<br />时间O(n)。<br />代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    void main();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    xbbbz::main();return 0;</span><br><span class="line">&#125;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    #define IOSFAST ios::sync_with_stdio(false),cin.tie(0);</span><br><span class="line">    #define int long long</span><br><span class="line">    const int N=2e5+10;</span><br><span class="line">    vector&lt;int&gt;ed[N];</span><br><span class="line">    struct node&#123;int x,y,z;&#125;;</span><br><span class="line">    vector&lt;node&gt;xx;</span><br><span class="line">    int ans=0;</span><br><span class="line">    int n,c,s1,s2;</span><br><span class="line">    int fa[N],dep[N];</span><br><span class="line">    int d1[N],d2[N],d3[N];</span><br><span class="line">    bool vis[N];</span><br><span class="line">    void dfs1(int u,int f)&#123;</span><br><span class="line">        dep[u]=dep[f]+1;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        if(dep[u]&gt;dep[c])c=u;</span><br><span class="line">        for(int v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int f)&#123;</span><br><span class="line">        d1[u]=d1[f]+1;</span><br><span class="line">        for(int v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs2(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs3(int u,int f)&#123;</span><br><span class="line">        d2[u]=d2[f]+1;</span><br><span class="line">        for(int v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs3(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!vis[u])&#123;</span><br><span class="line">            if(d1[u]&gt;=d2[u])xx.push_back((node)&#123;s1,u,u&#125;);</span><br><span class="line">            else xx.push_back((node)&#123;s2,u,u&#125;);</span><br><span class="line">            ans+=max(d1[u],d2[u])-1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void sol()&#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)ed[i].clear();</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            ed[u].push_back(v),ed[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(dep,0,sizeof(dep));dfs1(1,0);s1=c;</span><br><span class="line">        memset(dep,0,sizeof(dep));dfs1(s1,0);s2=c;</span><br><span class="line">        int len=-1;</span><br><span class="line">        for(int i=s2;i;i=fa[i])&#123;</span><br><span class="line">            len++;vis[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs2(s1,0);dfs3(s2,0);</span><br><span class="line">        for(int i=s2;i!=s1;i=fa[i])&#123;</span><br><span class="line">            xx.push_back((node)&#123;i,s1,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=len*(len+1)/2;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        for(auto i:xx)&#123;</span><br><span class="line">            cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;&quot; &quot;&lt;&lt;i.z&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void main()&#123;</span><br><span class="line">        IOSFAST;</span><br><span class="line">        int T=1;</span><br><span class="line">        while(T--)&#123;</span><br><span class="line">            sol();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zoj-3820-building-fire-stations"><a class="markdownIt-Anchor" href="#zoj-3820-building-fire-stations"></a> <a href="https://pintia.cn/problem-sets">ZOJ 3820, Building Fire Stations</a></h2><p>题干：<br />给你一颗树。选两个点做消防站，使得全部点到最近消防站的最大距离最小。<br />思路：<br />能够yy到两个点选在树的直径上，于是能够二分答案，答案为 mid 的时候两个端点就应该选  st+mid   和  ed-mid 这两个点 （st、ed是树的直径的端点），然后枚举中间的那些点是否满足条件来检验就够了。<br />代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    void main();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    return xbbbz::main(),0;</span><br><span class="line">&#125;</span><br><span class="line">namespace xbbbz&#123;</span><br><span class="line">    const int N=2e5+10;</span><br><span class="line">    vector&lt;int&gt;ed[N];</span><br><span class="line">    int n,c=0;</span><br><span class="line">    int s1,s2,len;</span><br><span class="line">    int ans1,ans2;</span><br><span class="line">    int dep[N],fa[N],dep1[N],dep2[N];</span><br><span class="line">    struct node&#123;</span><br><span class="line">        int u,f;</span><br><span class="line">    &#125;;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    void dfs1(int u,int f)&#123;</span><br><span class="line">        while(!q.empty())q.pop();</span><br><span class="line">        q.push(&#123;u,f&#125;);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            u=q.front().u,f=q.front().f,q.pop();</span><br><span class="line">            dep[u]=dep[f]+1;</span><br><span class="line">            fa[u]=f;</span><br><span class="line">            if(dep[u]&gt;dep[c])c=u;</span><br><span class="line">            for(int v: ed[u])&#123;</span><br><span class="line">                if(v==f)continue;</span><br><span class="line">                q.push((node)&#123;v,u&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfsans1(int u,int f)&#123;</span><br><span class="line">        q.push(&#123;u,f&#125;);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            u=q.front().u,f=q.front().f,q.pop();</span><br><span class="line">            dep1[u]=dep1[f]+1;</span><br><span class="line">            for(int v: ed[u])&#123;</span><br><span class="line">                if(v==f)continue;</span><br><span class="line">                q.push((node)&#123;v,u&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfsans2(int u,int f)&#123;</span><br><span class="line">        q.push(&#123;u,f&#125;);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            u=q.front().u,f=q.front().f,q.pop();</span><br><span class="line">            dep2[u]=dep2[f]+1;</span><br><span class="line">            for(int v: ed[u])&#123;</span><br><span class="line">                if(v==f)continue;</span><br><span class="line">                q.push((node)&#123;v,u&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int pd(int x)&#123;</span><br><span class="line">        memset(dep,0,sizeof(dep));</span><br><span class="line">        ans1=ans2=s2;</span><br><span class="line">        for(int i=1;i&lt;=x;i++)&#123;</span><br><span class="line">            ans1=fa[ans1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=(len-x);i++)&#123;</span><br><span class="line">            ans2=fa[ans2];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(dep1,0,sizeof(dep1));</span><br><span class="line">        memset(dep2,0,sizeof(dep2));</span><br><span class="line">        while(!q.empty())q.pop();</span><br><span class="line">        dfsans1(ans1,0);</span><br><span class="line">        while(!q.empty())q.pop();</span><br><span class="line">        dfsans2(ans2,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int res=min(dep1[i],dep2[i]);</span><br><span class="line">            if(res&gt;x+1)return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int bsh(int l,int r)&#123;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            int mid=(l+r)&gt;&gt;1;</span><br><span class="line">            if(pd(mid))r=mid;</span><br><span class="line">            else l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        pd(l);</span><br><span class="line">        if(ans1==ans2)ans1=fa[ans1];</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">    void sol()&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)ed[i].clear();</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int x,y;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            ed[x].push_back(y),ed[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(dep,0,sizeof(dep)),dfs1(1,0);s1=c;</span><br><span class="line">        memset(dep,0,sizeof(dep)),dfs1(s1,0),s2=c;</span><br><span class="line">        len=dep[s2]-dep[s1];</span><br><span class="line">        cout&lt;&lt;bsh(0,len/2)&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    void main()&#123;</span><br><span class="line">        ios::sync_with_stdio(false),cin.tie(0);</span><br><span class="line">        int T;cin&gt;&gt;T;</span><br><span class="line">        while(T--)&#123;</span><br><span class="line">            sol();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数位dp</title>
      <link href="/2024/10/09/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2024/10/09/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋数位dpfontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋数位dpfontcenter"></a> <center><font color="red" font face="仿宋">数位dp</font></center></h1><h2 id="p4127ahoi2009-同类分布"><a class="markdownIt-Anchor" href="#p4127ahoi2009-同类分布"></a> <a href="https://www.luogu.com.cn/problem/P4127">P4127[AHOI2009] 同类分布</a></h2><p>题干<br /><em><strong>给出两个数a,b，求出[a,b]中各位数字之和能整除原数的数的个数。</strong></em><br /><em><strong>1≤a≤b≤1e18</strong></em><br />解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,bool lim,int sum,int nowsum,int qm)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[qm][nowsum][len]!=-1)return f[qm][nowsum][len];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if((sum==nowsum)&amp;&amp;(qm==0))return 1;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    int up=9;</span><br><span class="line">    if(lim)up=a[len];</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(nowsum+i&gt;sum)continue;</span><br><span class="line">        res+=dfs(len-1,lim&amp;&amp;i==a[len],sum,nowsum+i,(qm+(i*m10[len-1]%sum))%sum);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[qm][nowsum][len]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p2657-scoi2009-windy-数"><a class="markdownIt-Anchor" href="#p2657-scoi2009-windy-数"></a> <a href="https://www.luogu.com.cn/problem/P2657"> P2657 [SCOI2009] windy 数 </a></h2><p>题干<br /><em><strong>不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。</strong></em><br /><em><strong>windy想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？</strong></em><br /><em><strong>对于全部的测试点，保证 1≤a≤b≤2e9</strong></em><br />解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int last,int len,bool lim,bool qd)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[last][len][qd]!=-1)return f[last][len][qd];</span><br><span class="line">    if(len==0)return 1;</span><br><span class="line">    int up=9;</span><br><span class="line">    int res=0;</span><br><span class="line">    if(lim)up=a[len];</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(qd)res+=dfs(i,len-1,lim&amp;&amp;(i==a[len]),i==0);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(abs(i-last)&lt;2)continue;</span><br><span class="line">            res+=dfs(i,len-1,lim&amp;&amp;(i==a[len]),0);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[last][len][qd]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p3413-sac1-萌数"><a class="markdownIt-Anchor" href="#p3413-sac1-萌数"></a> <a href="https://www.luogu.com.cn/problem/P3413"> P3413 SAC#1 - 萌数 </a></h2><p>题干<br /><em><strong>只有满足“存在长度至少为 2 的回文子串”的数是萌的——也就是说，101 是萌的，因为 101 本身就是一个回文数；110 是萌的，因为包含回文子串 11；但是 102 不是萌的，1201 也不是萌的。</strong></em><br /><em><strong>现在 SOL 想知道从 l 到 r 的所有整数中有多少个萌数。l,r&lt;1e1000</strong></em><br />解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int last1,int last2,bool lim,bool qd,bool meng)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][last1][last2][qd][meng]!=-1)return f[len][last1][last2][qd][meng];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if(meng)return 1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if((meng)||(!qd&amp;&amp;(last1==i))||(!qd&amp;&amp;(last2==i)))res+=dfs(len-1,i,last1,lim&amp;&amp;(i==up),0,1),res%=mod;</span><br><span class="line">        else res+=dfs(len-1,i,qd?11:last1,lim&amp;&amp;(i==up),qd&amp;&amp;(i==0),meng);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][last1][last2][qd][meng]=res%mod;</span><br><span class="line">    return res%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cf55d-beautiful-numbers"><a class="markdownIt-Anchor" href="#cf55d-beautiful-numbers"></a> <a href="http://codeforces.com/problemset/problem/55/D">CF55D  Beautiful numbers </a></h2><p>题干<br /><em><strong>Volodya 认为一个数字 xx 是美丽的，当且仅当 x∈Z+ 并且对于 x 的每一个非零位上的数 y，都有 y∣x。</strong></em><br /><em><strong>你需要帮助他算出在区间 [l,r] 中有多少个数是美丽的。</strong></em><br /><em><strong>t 组数据。</strong></em><br /><em><strong>1≤t≤10,1≤l≤r≤9×1e18</strong></em><br />解法<br />记录对1~9的最小公倍数2520取模的值,记录当前所用数位的LCM<br />是1到9中任取一些数作lcm，有很多值是根本取不到的，浪费了很多空间。我们预处理一下，最多只有48种可能，远远小于2520，建立映射的关系，将其中的一维压成50，大大减小了空间占用，使得空间变得可以接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int qm,int nowlcm,int lim)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][qm][nowlcm]!=-1)return f[len][qm][nowlcm];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if(qm%(lc[nowlcm])==0)return 1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        res+=dfs(len-1,(qm*10+i)%2520,i==0?nowlcm:numlc[lcm(lc[nowlcm],i)],lim&amp;&amp;(i==up));</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][qm][nowlcm]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hdu-6148-valley-numer"><a class="markdownIt-Anchor" href="#hdu-6148-valley-numer"></a> <a href="https://acm.hdu.edu.cn/showproblem.php?pid=6148">hdu 6148 Valley Numer</a></h2><p>题干<br /><em><strong>当一个数字，从左到右依次看过去数字没有出现先递增接着递减的“山峰”现象，就被称作 Valley Number。它可以递增，也可以递减，还可以先递减再递增。在递增或递减的过程中可以出现相等的情况。</strong></em><br /><em><strong>比如，1，10，12，212，32122都是 Valley Number。</strong></em><br /><em><strong>121，12331，21212则不是。</strong></em><br /><em><strong>度度熊想知道不大于N的Valley Number数有多少。</strong></em><br /><em><strong>注意，前导0是不合法的。</strong></em><br /><em><strong>● 1≤T≤200</strong></em><br /><em><strong>● 1≤length(N)≤100</strong></em><br />解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int last,bool lim,bool qd,bool sh)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][last][qd][sh]!=-1)return f[len][last][qd][sh];</span><br><span class="line">    if(len==0)return 1;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(sh&amp;&amp;i&lt;last)continue;</span><br><span class="line">        res+=dfs(len-1,i,lim&amp;&amp;(i==up),qd&amp;&amp;(i==0),sh||((!sh)&amp;&amp;(!qd)&amp;&amp;(i&gt;last)));</span><br><span class="line">        res%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][last][qd][sh]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cf628d-magic-numbers"><a class="markdownIt-Anchor" href="#cf628d-magic-numbers"></a> <a href="http://codeforces.com/problemset/problem/628/D">CF628D Magic Numbers</a></h2><p>题干<br /><em><strong>给你 4 个数 m,d,l,r保证 l,r位数相同。</strong></em><br /><em><strong>问满足以下条件的数 x 的个数：</strong></em><br /><em><strong>l≤x≤r x 的偶数位是 d，奇数位不是 d。 （这里定义偶数位为从高位往低位的数的偶数位）</strong></em><br /><em><strong>m∣x</strong></em><br /><em><strong>答案对 1000000007 取模。</strong></em><br /><em><strong>1≤m≤2000,0≤d≤9,1≤l≤r≤1e2000</strong></em><br />解法<br />由于l,r位数相同,我们可以强制让其没有前导0.(因为有前导0时,l,r的dfs的答案必定相同,相减为0,不需要统计)<br />我们还需额外判断 x=l 是否可行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int qm,bool lim,bool qd,bool odd)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][qm][odd]!=-1)return f[len][qm][odd]%mod;</span><br><span class="line">    if(len==0)return qm==0;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(qd&amp;&amp;(i==0))continue;</span><br><span class="line">        if(odd&amp;&amp;i==d)continue;</span><br><span class="line">        if(!odd&amp;&amp;i!=d)continue;</span><br><span class="line">        res+=dfs(len-1,(qm*10+i)%m,lim&amp;&amp;(i==up),0,odd^1);res%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][qm][odd]=res%mod;</span><br><span class="line">    return res%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/10/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorbrown-font-face仿宋背包问题fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorbrown-font-face仿宋背包问题fontcenter"></a> <center><font color="brown" font face="仿宋">背包问题</font></center></h1><p><a href="https://oi-wiki.org"> <font size = 5 font color = "red"> OI Wiki </font> </a></p><h2 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 01背包</h2><p>每个物品可以取1个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    for (int l = W; l &gt;= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h2><p>(每个物品可以取无数次)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=w[i];j&lt;=m;j++)</span><br><span class="line">        f[j]=max(f[j],f[j-w[i]]+d[i]);</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a class="markdownIt-Anchor" href="#多重背包"></a> 多重背包</h2><p>(每个物品可以取num[i]次)</p><h3 id="拆成01背包"><a class="markdownIt-Anchor" href="#拆成01背包"></a> 拆成01背包</h3><h3 id="二进制分组优化01背包"><a class="markdownIt-Anchor" href="#二进制分组优化01背包"></a> 二进制分组优化+01背包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;=num[i];j&lt;&lt;=1)&#123;v2[++k]=v[i]*j;w2[k]=w[i]*j;num[i]-=j;&#125;</span><br><span class="line">    if(num[i])v2[++k]=num[i]*v[i],w2[k]=num[i]*w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列优化"><a class="markdownIt-Anchor" href="#单调队列优化"></a> 单调队列优化</h3><p>(待补充)</p><h2 id="混合背包"><a class="markdownIt-Anchor" href="#混合背包"></a> 混合背包</h2><p>(完全背包+多重背包)</p><h2 id="二维费用背包"><a class="markdownIt-Anchor" href="#二维费用背包"></a> 二维费用背包</h2><p>有 [n] 个任务需要完成，完成第 [i] 个任务需要花费 t[i] 分钟，产生 c[i] 元的开支。<br />现在有 [T] 分钟时间， [W] 元钱来处理这些任务，求最多能完成多少任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    for(int j=m;j&gt;=x;j--)</span><br><span class="line">        for(int k=t;k&gt;=y;k--)</span><br><span class="line">            dp[j][k]=max(dp[j-x][k-y]+1,dp[j][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包"><a class="markdownIt-Anchor" href="#分组背包"></a> 分组背包</h2><p><strong>有 [n] 件物品和一个大小为 [m] 的背包，第 [i] 个物品的价值为 w[i]，体积为 v[i].</strong><br /><strong>同时，每个物品属于一个组，同组内最多只能选择一个物品。求背包能装载物品的最大总价值.</strong><br />其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int k = 1; k &lt;= ts; k++)          // 循环每一组</span><br><span class="line">  for (int i = m; i &gt;= 0; i--)         // 循环背包容量</span><br><span class="line">    for (int j = 1; j &lt;= cnt[k]; j++)  // 循环该组的每一个物品</span><br><span class="line">      if (i &gt;= w[t[k][j]])             // 背包容量充足</span><br><span class="line">        dp[i] = max(dp[i],</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移</span><br></pre></td></tr></table></figure><p>这里要注意：一定不能搞错循环顺序，这样才能保证正确性。</p><h2 id="有依赖的背包"><a class="markdownIt-Anchor" href="#有依赖的背包"></a> 有依赖的背包</h2><h3 id="p1064-noip2006-提高组-金明的预算方案"><a class="markdownIt-Anchor" href="#p1064-noip2006-提高组-金明的预算方案"></a> <em><strong><a href="https://www.luogu.com.cn/problem/P1064"> P1064 [NOIP2006 提高组] 金明的预算方案 </a></strong></em></h3><p><strong>金明有 [n] 元钱，想要买 [m] 个物品，第 [i] 件物品的价格为 v[i] ，重要度为 p[i] 。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。</strong><br />*<em>目标是让所有购买的物品的 v[i]<em>p[i] 之和最大。</em></em><br />解法:考虑分类讨论。对于一个主件和它的若干附件，有以下几种可能：只买主件，买主件 + 某些附件。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p><p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p><h3 id="p3961-tjoi2013-黄金矿工"><a class="markdownIt-Anchor" href="#p3961-tjoi2013-黄金矿工"></a> <em><strong><a href="https://www.luogu.com.cn/problem/P3961"> P3961 [TJOI2013] 黄金矿工 </a></strong></em></h3><p>题目描述<br />小 A 最近迷上了在上课时玩《黄金矿工》这款游戏。为了避免被老师发现，他必须小心翼翼，因此他总是输。<br />在输掉自己所有的金币后，他向你求助。每个黄金可以看做一个点（没有体积）。现在给出你 N 个黄金的坐标，挖到它们所需要的时间以及它们的价值。有些黄金在同一条直线上，这时候你必须按顺序挖。你可以瞬间把钩子转到任意角度。<br />小 A 一开始在坐标 (0,0)，请你帮助小 A 算出在时间 T 内他最多可以得到多少价值的金子。<br />范围: N(200) T(4e4)</p><h2 id="背包练习"><a class="markdownIt-Anchor" href="#背包练习"></a> 背包练习</h2><h3 id="p1450-haoi2008-硬币购物"><a class="markdownIt-Anchor" href="#p1450-haoi2008-硬币购物"></a> <a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008] 硬币购物</a></h3><p><em><strong>背包+容斥</strong></em><br />先考虑没有个数限制的情况,f[i]表示没有限制的方案数;<br />答案为f[s]-不合法的情况;<br />考虑一种硬币超过限制时的方案数为f[s-(次硬币的总数+1)*此硬币的价值];<br />然后有重复,考虑对不合法的情况进行容斥.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单算法模板总结</title>
      <link href="/2024/10/07/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/07/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋简单算法模板总结fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋简单算法模板总结fontcenter"></a> <center><font color="red" font face="仿宋">简单算法模板总结</font></center></h1><h2 id="快速幂"><a class="markdownIt-Anchor" href="#快速幂"></a> 快速幂</h2><p><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fp(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res*=a,res%=mod;</span><br><span class="line">        a*=a;a%=mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h2><p><a href="https://www.luogu.com.cn/problem/P3370"> P3370 【模板】字符串哈希 </a><br /><em>自然溢出方法：利用unsigned long long 自然溢出,相当于自动对2^64−1取模</em><br /><em>必要时可以使用双 <strong>hash</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ull unsigned long long</span><br><span class="line">ull has(string s)&#123;</span><br><span class="line">    ull res=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        res=res*131+ull(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛素数"><a class="markdownIt-Anchor" href="#线性筛素数"></a> 线性筛素数</h2><p><a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a><br /><em>这个算法使用“某数×质数”去筛合数，一个合数一定会被它的最小质因数筛掉</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(!vis[i])pr[++cnt]=i;</span><br><span class="line">    for(int j=1;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=n;j++)&#123;</span><br><span class="line">        vis[i*pr[j]]=1;</span><br><span class="line">        if(i%pr[j]==0)break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2><p><a href="https://www.luogu.com.cn/problem/B3644"> B3644 【模板】拓扑排序 / 家谱树 </a></p><ol><li>拓扑实现的步骤</li></ol><ul><li>计算每个点的入度。</li><li>入度为 0 就加入队列。</li><li>当队列不为空则循环：<ul><li>取出队首元素并输出</li><li>遍历队首元素的连边，对应节点的入度 −1</li><li>当对应的节点入度为 0 就加入队列</li></ul></li></ul><ol start="2"><li>代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)if(!rd[i])q.push(i);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int v : ed[u])&#123;</span><br><span class="line">            rd[v]--;</span><br><span class="line">            if(!rd[v])q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a class="markdownIt-Anchor" href="#floyd"></a> Floyd</h2><p><a href="https://www.luogu.com.cn/problem/B3647"> B3647 【模板】Floyd </a><br /><a href="https://www.luogu.com.cn/problem/B3611"> B3611 【模板】传递闭包 </a><br />O(n^3)求最短路,传递闭包<br /><em>传递闭包定义如下</em><br /><img src="https://pic.imgdb.cn/item/6703c3b4d29ded1a8c6fd9a0.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=min(f[i][k]+f[k][j],f[i][j]);</span><br><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(!f[i][j])f[i][j]=f[i][k]&amp;f[k][j];</span><br></pre></td></tr></table></figure><h2 id="判断负环"><a class="markdownIt-Anchor" href="#判断负环"></a> 判断负环</h2><p><a href="https://www.luogu.com.cn/problem/P3385"> P3385 【模板】负环 </a><br />spfa判负环<br />(可以松弛就松弛,松弛后如果没进队就进队)<br />如果一个点进队超过n次,则出现负环.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool spfa(int x)&#123;</span><br><span class="line">    while(!q.empty())q.pop();</span><br><span class="line">    q.push(x);inq[x]++;vis[x]=1;dis[x]=0;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();vis[u]=0;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v]=1;q.push(v);inq[v]++;</span><br><span class="line">                    if(inq[v]&gt;n)return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单源最短路"><a class="markdownIt-Anchor" href="#单源最短路"></a> 单源最短路</h2><p><a href="https://www.luogu.com.cn/problem/P4779"> P4779 【模板】单源最短路径（标准版）</a><br /><a href="https://www.zhihu.com/question/292283275">***<font color = "red">SPFA已死</font>***</a></p><p><em><strong>堆优dijkstra</strong></em><br /><em>priority_queue默认是大根堆,可以重载小于号</em><br />(两个集合:一个是已确定的最优集合,另一个为它的补集,每次从补集中选最优的加入前面的集合)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int v,w;</span><br><span class="line">    friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line">        return a.w&gt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">vector&lt;node&gt;ed[MN];</span><br><span class="line">void dij(int s)&#123;</span><br><span class="line">    dis[s]=0;q.push((node)&#123;s,dis[s]&#125;);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.top().v;q.pop();</span><br><span class="line">        if(vis[u])continue; //this line is very important</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(vis[v])continue;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.push((node)&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2><p>维护区间大小已知的多个区间最值(线性复杂度)<br />用双端队列维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    while(!q.empty()&amp;&amp;q.front()&lt;=i-k)q.pop_front();</span><br><span class="line">    while(!q.empty()&amp;&amp;a[q.back()]&gt;=a[i])q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    b1[i]=a[q.front()];</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())q.pop_back();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    while(!q.empty()&amp;&amp;q.front()&lt;=i-k)q.pop_front();</span><br><span class="line">    while(!q.empty()&amp;&amp;a[q.back()]&lt;=a[i])q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    b2[i]=a[q.front()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2><p>找到左或右第一个大于(小于)此元素的下标(线性复杂度)<br />用栈维护<br />下面以找到右面第一个大于此元素的下标为例<br />如果不存在则下标默认为零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">    while(!ed.empty()&amp;&amp;a[ed.back()]&lt;=a[i])ed.pop_back();</span><br><span class="line">    if(!ed.empty())b[i]=ed.back();</span><br><span class="line">    ed.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> int find(int x)&#123;</span><br><span class="line">    if(x!=fa[x])&#123;</span><br><span class="line">        return fa[x]=find(fa[x]);//路径压缩</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void hb(int x,int y)&#123;</span><br><span class="line">    int fx=find(x);int fy=find(y);</span><br><span class="line">    if(fx!=fy)fa[fy]=fx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><p><a href="https://www.luogu.com.cn/problem/P3366"> P3366 【模板】最小生成树 </a></p><p><em><strong>Kruskal：</strong></em><br />先把边按照权值进行排序，用贪心的思想优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool kls()&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u=ed[i].u;</span><br><span class="line">        int v=ed[i].v;</span><br><span class="line">        if(find(u)!=find(v))&#123;</span><br><span class="line">            hb(u,v);</span><br><span class="line">            cnt++;</span><br><span class="line">            ans+=ed[i].w;</span><br><span class="line">            if(cnt==n-1)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt&lt;n-1)return 0;</span><br><span class="line">    else return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树板子segment-tree"><a class="markdownIt-Anchor" href="#线段树板子segment-tree"></a> 线段树板子(segment-tree)</h2><ol><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a><br />区间加 区间求和</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l];return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        tag[ls]+=tag[u];</span><br><span class="line">        tag[rs]+=tag[u];</span><br><span class="line">        sum[ls]+=tag[u]*(mid-l+1);</span><br><span class="line">        sum[rs]+=tag[u]*(r-mid);</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=(r-l+1)*k;</span><br><span class="line">            tag[u]+=k;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)return sum[u];</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://www.luogu.com.cn/problem/P3373"> P3373 【模板】线段树 2 </a><br />区间加 区间乘 区间求和</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">        sum[u]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        sum[ls]*=multag[u];sum[ls]%=mod;</span><br><span class="line">        sum[rs]*=multag[u];sum[rs]%=mod;</span><br><span class="line">        sum[ls]+=addtag[u]*(mid-l+1);sum[ls]%=mod;</span><br><span class="line">        sum[rs]+=addtag[u]*(r-mid);sum[rs]%=mod;</span><br><span class="line">        multag[ls]*=multag[u];multag[ls]%=mod;</span><br><span class="line">        multag[rs]*=multag[u];multag[rs]%=mod;</span><br><span class="line">        addtag[ls]*=multag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]*=multag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[ls]+=addtag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]+=addtag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[u]=0;multag[u]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    void addupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=k*(r-l+1);sum[u]%=mod;</span><br><span class="line">            addtag[u]+=k;addtag[u]%=mod; </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)addupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)addupd(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void mulupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]*=k;sum[u]%=mod;</span><br><span class="line">            multag[u]*=k;multag[u]%=mod;</span><br><span class="line">            addtag[u]*=k;addtag[u]%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)mulupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)mulupd(rs,mid+1,r,xl,xr,k); </span><br><span class="line">        pushup(u);  </span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u];</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)&#123;res+=cx(ls,l,mid,xl,xr);res%=mod;&#125;</span><br><span class="line">        if(xr&gt;mid)&#123;res+=cx(rs,mid+1,r,xl,xr);res%=mod;&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure><h2 id="树链剖分重链剖分"><a class="markdownIt-Anchor" href="#树链剖分重链剖分"></a> 树链剖分(重链剖分)</h2><p>路径加 子树加 路径求和 子树求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">struct SMT&#123;</span><br><span class="line">    int sum[MN&lt;&lt;2],tag[MN&lt;&lt;2];</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=(sum[ls]+sum[rs])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=w[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        (sum[ls]+=tag[u]*(mid-l+1)%mod)%=mod;</span><br><span class="line">        (sum[rs]+=tag[u]*(r-mid)%mod)%=mod;</span><br><span class="line">        (tag[ls]+=tag[u])%=mod;</span><br><span class="line">        (tag[rs]+=tag[u])%=mod;</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            (sum[u]+=k*(r-l+1))%=mod;</span><br><span class="line">            (tag[u]+=k)%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">struct HPD&#123;</span><br><span class="line">    int top[MN],siz[MN],dep[MN],son[MN],id[MN],fa[MN],cnt=0;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        w[cnt]=a[u];</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpath(int x,int y,int k)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            T.update(1,1,n,id[top[x]],id[x],k);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        T.update(1,1,n,id[x],id[y],k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpath(int x,int y)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            res+=T.cx(1,1,n,id[top[x]],id[x]);res%=mod;</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        res+=T.cx(1,1,n,id[x],id[y]);res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpoint(int u,int k)&#123;</span><br><span class="line">        T.update(1,1,n,id[u],id[u]+siz[u]-1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpoint(int u)&#123;</span><br><span class="line">        return T.cx(1,1,n,id[u],id[u]+siz[u]-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure><h2 id="lca"><a class="markdownIt-Anchor" href="#lca"></a> LCA</h2><p>1.树剖LCA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct HPD&#123;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    int dep[MN],siz[MN],son[MN],id[MN],fa[MN],top[MN],cnt=0;</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int lca(int x,int y)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl 不全总结(acm竞赛)</title>
      <link href="/2024/10/02/stl%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/02/stl%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋stl不全总结fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋stl不全总结fontcenter"></a> <center><font color="red" font face="仿宋">stl不全总结</font></center></h1><p><font size=7 font color= "gree"> *** 待补充</font><br /><em><strong><font size=5 font color= "gree">不全总结,目前本蒟蒻常用到的,等待补充 </font></strong></em><br />参考<a href="https://wyqz.top/p/870124582.html#toc-heading-57">C++ STL 总结-基于算法竞赛（悠享版）</a> orz /bx<br /><em><strong><font size=5 font color= "pinkf">更详细的内容请见</strong></em><a href="https://oi-wiki.org/">oi-wiki</a></font><br /><em><strong><font size=5 font color= "pinkf">请见</strong></em><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5"><br />C++ 参考手册</a></font></p><h2 id="stl简介"><a class="markdownIt-Anchor" href="#stl简介"></a> stl简介</h2><h3 id="序列式容器"><a class="markdownIt-Anchor" href="#序列式容器"></a> 序列式容器</h3><p>向量(vector) 后端可高效增加元素的顺序表。<br />数组(array)C++11，定长的顺序表，C 风格数组的简单包装。<br />双端队列(deque) 双端都可高效增加元素的顺序表。<br />列表(list) 可以沿双向遍历的链表。<br />单向列表(forward_list) 只能沿一个方向遍历的链表。</p><h3 id="关联式容器"><a class="markdownIt-Anchor" href="#关联式容器"></a> 关联式容器</h3><p>集合(set) 用以有序地存储 互异 元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。<br />多重集合(multiset) 用以有序地存储元素的容器。允许存在相等的元素。<br />映射(map) 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。<br />多重映射(multimap) 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。</p><h3 id="无序关联式容器"><a class="markdownIt-Anchor" href="#无序关联式容器"></a> 无序（关联式）容器</h3><p>无序（多重）集合(unordered_set/unordered_multiset)C<ins>11，与 set/multiset 的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。<br />无序（多重）映射(unordered_map/unordered_multimap)C</ins>11，与 map/multimap 的区别在于键 (key) 无序，只关心 “键与值的对应关系”，使用哈希实现。</p><h3 id="容器适配器"><a class="markdownIt-Anchor" href="#容器适配器"></a> 容器适配器</h3><p>容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 clear() 函数……）。<br />「适配器是使一种事物的行为类似于另外一种事物行为的一种机制」，适配器对容器进行包装，使其表现出另外一种行为。<br />栈(stack) 后进先出 (LIFO) 的容器，默认是对双端队列（deque）的包装。<br />队列(queue) 先进先出 (FIFO) 的容器，默认是对双端队列（deque）的包装。<br />优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（vector）的包装。</p><h3 id="共有函数"><a class="markdownIt-Anchor" href="#共有函数"></a> 共有函数</h3><p>=：有赋值运算符以及复制构造函数。<br />begin()：返回指向开头元素的迭代器。<br />end()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，但它是末尾元素的后继。<br />size()：返回容器内的元素个数。<br />max_size()：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。<br />empty()：返回容器是否为空。<br />swap()：交换两个容器。<br />clear()：清空容器。</p><h2 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h2><p>在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。类似的概念在其他很多高级语言中都存在，如 Python 的 <strong>iter</strong> 函数，C# 的 IEnumerator。</p><h3 id="基础使用"><a class="markdownIt-Anchor" href="#基础使用"></a> 基础使用</h3><p>迭代器听起来比较晦涩，其实迭代器本身可以看作一个数据指针。迭代器主要支持两个运算符：自增 (++) 和解引用（单目 * 运算符），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。<br />指向某个 STL 容器 container 中元素的迭代器的类型一般为 container::iterator。<br />迭代器可以用来遍历容器，例如，下面两个 for 循环的效果是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; data(10);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; data.size(); i++)</span><br><span class="line">  cout &lt;&lt; data[i] &lt;&lt; endl;  // 使用下标访问元素</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator iter = data.begin(); iter != data.end(); iter++)</span><br><span class="line">  cout &lt;&lt; *iter &lt;&lt; endl;  // 使用迭代器访问元素</span><br><span class="line">// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码</span><br></pre></td></tr></table></figure><blockquote><p>大部分选手都喜欢使用 auto 来代替繁琐的迭代器声明。根据 2021 年 9 月发布的 关于 NOI 系列活动中编程语言使用限制的补充说明，NOI 系列比赛（包括 CSP J/S）在评测时将使用 C++14，这个版本已经支持了 auto 关键字。</p></blockquote><h3 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h3><p>很多 STL 函数 都使用迭代器作为参数。<br />可以使用 std::advance(it, n) 将迭代器 it 向后移动 n 步；若 n 为负数，则对应向前移动，此时迭代器必须满足双向迭代器，否则行为未定义。<br />在 C<ins>11 以后可以使用 std::next(it) 获得向前迭代器 it 的后继（此时迭代器 it 不变），std::next(it, n) 获得向前迭代器 it 的第 n 个后继。<br />在 C</ins>11 以后可以使用 std::prev(it) 获得双向迭代器 it 的前驱（此时迭代器 it 不变），std::prev(it, n) 获得双向迭代器 it 的第 n 个前驱。</p><h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2><h3 id="构造函数初始化"><a class="markdownIt-Anchor" href="#构造函数初始化"></a> 构造函数/初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建空vector; 常数复杂度</span><br><span class="line">vector&lt;int&gt; v0;</span><br><span class="line"></span><br><span class="line">// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度</span><br><span class="line">v0.reserve(3);</span><br><span class="line"></span><br><span class="line">// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度</span><br><span class="line">vector&lt;int&gt; v1(3);</span><br><span class="line"></span><br><span class="line">// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度</span><br><span class="line">vector&lt;int&gt; v2(3, 2);</span><br><span class="line"></span><br><span class="line">// 4. 创建一个初始空间为3的vector，其元素的默认值是1，</span><br><span class="line">// 并且使用v2的空间配置器; 线性复杂度</span><br><span class="line">vector&lt;int&gt; v3(3, 1, v2.get_allocator());</span><br><span class="line"></span><br><span class="line">// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度</span><br><span class="line">vector&lt;int&gt; v4(v2);</span><br><span class="line"></span><br><span class="line">// 6. 创建一个v4的拷贝vector v5，其内容是&#123;v4[1], v4[2]&#125;; 线性复杂度</span><br><span class="line">vector&lt;int&gt; v5(v4.begin() + 1, v4.begin() + 3);</span><br><span class="line"></span><br><span class="line">// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11</span><br><span class="line">vector&lt;int&gt; v6(std::move(v2));  // 或者 v6 = std::move(v2);</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:center"></th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">at()</td><td style="text-align:center"></td><td style="text-align:left"><a href="http://v.at">v.at</a>(pos) 返回容器中下标为 pos 的引用。如果数组越界抛出 std::out_of_range 类型的异常。</td></tr><tr><td style="text-align:left">operator[]</td><td style="text-align:center"></td><td style="text-align:left">v[pos] 返回容器中下标为 pos 的引用。不执行越界检查。</td></tr><tr><td style="text-align:left">front()</td><td style="text-align:center"></td><td style="text-align:left">v.front() 返回首元素的引用。</td></tr><tr><td style="text-align:left">back()</td><td style="text-align:center"></td><td style="text-align:left">v.back() 返回末尾元素的引用。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mark down 简单入门</title>
      <link href="/2024/10/02/markdown%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/02/markdown%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/">markdown 官方教程</a></p><h1 id="center-font-face仿宋-font-color-orange-mark-down-简单入门-fontcenter"><a class="markdownIt-Anchor" href="#center-font-face仿宋-font-color-orange-mark-down-简单入门-fontcenter"></a> <center> <font face="仿宋" font color = "orange"> mark down 简单入门 </font></center></h1><p><code>这里面是源码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &lt;center&gt; &lt;font face=&quot;仿宋&quot; font color = &quot;orange&quot;&gt; mark down 简单入门 &lt;/font&gt;&lt;/center&gt;</span><br><span class="line">(html)</span><br></pre></td></tr></table></figure><h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">最多可支持到六级标题</span><br></pre></td></tr></table></figure><h2 id="段落换行"><a class="markdownIt-Anchor" href="#段落换行"></a> 段落&amp;&amp;换行</h2><p>美人迈兮音尘阙，</p><p>隔千里兮共明月。</p><h2 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h2><p><em>恰似一江春水向东流</em><br /><strong>恰似一江春水向东流</strong><br /><em><strong>恰似一江春水向东流</strong></em><br /><mark>恰似一江春水向东流</mark><br /><u>恰似一江春水向东流</u><br /><s>恰似一江春水向东流</s><br />恰似一江春水向东流[^1]</p><hr /><hr /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体并加粗***</span><br><span class="line">==高亮==</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br><span class="line">~~删除线~~</span><br><span class="line">___分割线</span><br><span class="line">***分割线</span><br><span class="line">[^1]脚注</span><br></pre></td></tr></table></figure><h2 id="粘代码"><a class="markdownIt-Anchor" href="#粘代码"></a> 粘代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码内容在两行```之间</span><br></pre></td></tr></table></figure><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><ol><li>有序列表一</li><li>有序列表二<ul><li>无序列表</li></ul><ul><li>无序列表</li></ul></li><li>有序列表三<ol><li>有序列表三中的有序列表一</li><li>有序列表三中的有序列表二</li></ol></li><li>to de list<ul><li>[x] 吃饭</li><li>[ ] 睡觉</li><li>[ ] 玩游戏</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表一</span><br><span class="line">2. 有序列表二</span><br><span class="line">   - 无序列表</span><br><span class="line">   + 无序列表</span><br><span class="line">3. 有序列表三</span><br><span class="line">    1. 有序列表三中的有序列表一</span><br><span class="line">    2. 有序列表三中的有序列表二</span><br><span class="line">4. to de liset</span><br><span class="line">    - [x] 吃饭</span><br><span class="line">    - [ ] 睡觉</span><br><span class="line">    - [ ] 玩游戏</span><br></pre></td></tr></table></figure><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">height/cm</th><th style="text-align:right">weight/kg</th></tr></thead><tbody><tr><td style="text-align:left">xbb</td><td style="text-align:center">12312132132123132313231</td><td style="text-align:right">11111</td></tr><tr><td style="text-align:left">xzb</td><td style="text-align:center">6545645</td><td style="text-align:right">64564666666664646464564</td></tr><tr><td style="text-align:left">wwy</td><td style="text-align:center">48646464</td><td style="text-align:right">548845645456464</td></tr><tr><td style="text-align:left">people</td><td style="text-align:center">6445645645645645644</td><td style="text-align:right">45313123123123123</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|name| height/cm |weight/kg| //表头· </span><br><span class="line">|:---| :---: |---:| //分别表示居左 居中 居右 对齐</span><br><span class="line">|xbb|12312132132123132313231|11111|</span><br><span class="line">|xzb|6545645|64564666666664646464564|</span><br><span class="line">|wwy|48646464|548845645456464|</span><br><span class="line">|people|6445645645645645644|45313123123123123|</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="the-quarterly-results-look-great"><a class="markdownIt-Anchor" href="#the-quarterly-results-look-great"></a> The quarterly results look great!</h3><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br><span class="line">&gt; ### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><p><a href="https://www.bilibili.com/">bilibili</a><br /><a href="https://www.bilibili.com/" title="B站">bilibili</a><br /><a href="mailto:3156993539@qq.com">3156993539@qq.com</a><br />雪白白白子的 <em><strong><a href="https://megumi1101.github.io/">blog</a></strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bilibili](https://www.bilibili.com/)</span><br><span class="line">[bilibili](https://www.bilibili.com/ &quot;B站&quot;)</span><br><span class="line">&lt;3156993539@qq.com&gt;</span><br><span class="line">雪白白白子的 ***[blog](https://megumi1101.github.io/)***</span><br></pre></td></tr></table></figure><h2 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h2><p><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png)</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png" alt="image.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png&quot; alt=&quot;image.png&quot;&gt;</span><br><span class="line">(使用HTML语法)</span><br></pre></td></tr></table></figure><h2 id="写入latex公式katex"><a class="markdownIt-Anchor" href="#写入latex公式katex"></a> 写入latex公式(katex)</h2><ul><li>单行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x)=ax+b </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p><ul><li>多行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\begin{Bmatrix}a&amp;b\\c&amp;d\end{Bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x)=ax+b $$</span><br><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">a&amp;b\\</span><br><span class="line">c&amp;d</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
