<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数位dp</title>
      <link href="/2024/10/09/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2024/10/09/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋数位dpfontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋数位dpfontcenter"></a> <center><font color="red" font face="仿宋">数位dp</font></center></h1><h2 id="p4127ahoi2009-同类分布"><a class="markdownIt-Anchor" href="#p4127ahoi2009-同类分布"></a> <a href="https://www.luogu.com.cn/problem/P4127">P4127[AHOI2009] 同类分布</a></h2><h3 id="题干"><a class="markdownIt-Anchor" href="#题干"></a> 题干</h3><p><em><strong>给出两个数a,b，求出[a,b]中各位数字之和能整除原数的数的个数。</strong></em><br /><em><strong>1≤a≤b≤1e18</strong></em></p><h3 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,bool lim,int sum,int nowsum,int qm)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[qm][nowsum][len]!=-1)return f[qm][nowsum][len];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if((sum==nowsum)&amp;&amp;(qm==0))return 1;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    int up=9;</span><br><span class="line">    if(lim)up=a[len];</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(nowsum+i&gt;sum)continue;</span><br><span class="line">        res+=dfs(len-1,lim&amp;&amp;i==a[len],sum,nowsum+i,(qm+(i*m10[len-1]%sum))%sum);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[qm][nowsum][len]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p2657-scoi2009-windy-数"><a class="markdownIt-Anchor" href="#p2657-scoi2009-windy-数"></a> <a href="https://www.luogu.com.cn/problem/P2657"> P2657 [SCOI2009] windy 数 </a></h2><h3 id="题干-2"><a class="markdownIt-Anchor" href="#题干-2"></a> 题干</h3><p><em><strong>不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。</strong></em><br /><em><strong>windy想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？</strong></em><br /><em><strong>对于全部的测试点，保证 1≤a≤b≤2e9</strong></em></p><h3 id="解法-2"><a class="markdownIt-Anchor" href="#解法-2"></a> 解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int last,int len,bool lim,bool qd)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[last][len][qd]!=-1)return f[last][len][qd];</span><br><span class="line">    if(len==0)return 1;</span><br><span class="line">    int up=9;</span><br><span class="line">    int res=0;</span><br><span class="line">    if(lim)up=a[len];</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(qd)res+=dfs(i,len-1,lim&amp;&amp;(i==a[len]),i==0);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(abs(i-last)&lt;2)continue;</span><br><span class="line">            res+=dfs(i,len-1,lim&amp;&amp;(i==a[len]),0);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[last][len][qd]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p3413-sac1-萌数"><a class="markdownIt-Anchor" href="#p3413-sac1-萌数"></a> <a href="https://www.luogu.com.cn/problem/P3413"> P3413 SAC#1 - 萌数 </a></h2><h3 id="题干-3"><a class="markdownIt-Anchor" href="#题干-3"></a> 题干</h3><p><em><strong>只有满足“存在长度至少为 2 的回文子串”的数是萌的——也就是说，101 是萌的，因为 101 本身就是一个回文数；110 是萌的，因为包含回文子串 11；但是 102 不是萌的，1201 也不是萌的。</strong></em><br /><em><strong>现在 SOL 想知道从 l 到 r 的所有整数中有多少个萌数。l,r&lt;1e1000</strong></em></p><h3 id="解法-3"><a class="markdownIt-Anchor" href="#解法-3"></a> 解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int last1,int last2,bool lim,bool qd,bool meng)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][last1][last2][qd][meng]!=-1)return f[len][last1][last2][qd][meng];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if(meng)return 1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if((meng)||(!qd&amp;&amp;(last1==i))||(!qd&amp;&amp;(last2==i)))res+=dfs(len-1,i,last1,lim&amp;&amp;(i==up),0,1),res%=mod;</span><br><span class="line">        else res+=dfs(len-1,i,qd?11:last1,lim&amp;&amp;(i==up),qd&amp;&amp;(i==0),meng);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][last1][last2][qd][meng]=res%mod;</span><br><span class="line">    return res%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cf55d-beautiful-numbers"><a class="markdownIt-Anchor" href="#cf55d-beautiful-numbers"></a> <a href="http://codeforces.com/problemset/problem/55/D">CF55D  Beautiful numbers </a></h2><h3 id="题干-4"><a class="markdownIt-Anchor" href="#题干-4"></a> 题干</h3><p><em><strong>Volodya 认为一个数字 xx 是美丽的，当且仅当 x∈Z+ 并且对于 x 的每一个非零位上的数 y，都有 y∣x。</strong></em><br /><em><strong>你需要帮助他算出在区间 [l,r] 中有多少个数是美丽的。</strong></em><br /><em><strong>t 组数据。</strong></em><br /><em><strong>1≤t≤10,1≤l≤r≤9×1e18</strong></em></p><h3 id="解法-4"><a class="markdownIt-Anchor" href="#解法-4"></a> 解法</h3><p>记录对1~9的最小公倍数2520取模的值,记录当前所用数位的LCM<br />是1到9中任取一些数作lcm，有很多值是根本取不到的，浪费了很多空间。我们预处理一下，最多只有48种可能，远远小于2520，建立映射的关系，将其中的一维压成50，大大减小了空间占用，使得空间变得可以接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int qm,int nowlcm,int lim)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][qm][nowlcm]!=-1)return f[len][qm][nowlcm];</span><br><span class="line">    if(len==0)&#123;</span><br><span class="line">        if(qm%(lc[nowlcm])==0)return 1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        res+=dfs(len-1,(qm*10+i)%2520,i==0?nowlcm:numlc[lcm(lc[nowlcm],i)],lim&amp;&amp;(i==up));</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][qm][nowlcm]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hdu-6148-valley-numer"><a class="markdownIt-Anchor" href="#hdu-6148-valley-numer"></a> <a href="https://acm.hdu.edu.cn/showproblem.php?pid=6148">hdu 6148 Valley Numer</a></h2><h3 id="题干-5"><a class="markdownIt-Anchor" href="#题干-5"></a> 题干</h3><p><em><strong>当一个数字，从左到右依次看过去数字没有出现先递增接着递减的“山峰”现象，就被称作 Valley Number。它可以递增，也可以递减，还可以先递减再递增。在递增或递减的过程中可以出现相等的情况。</strong></em><br /><em><strong>比如，1，10，12，212，32122都是 Valley Number。</strong></em><br /><em><strong>121，12331，21212则不是。</strong></em><br /><em><strong>度度熊想知道不大于N的Valley Number数有多少。</strong></em><br /><em><strong>注意，前导0是不合法的。</strong></em><br /><em><strong>● 1≤T≤200</strong></em><br /><em><strong>● 1≤length(N)≤100</strong></em></p><h3 id="解法-5"><a class="markdownIt-Anchor" href="#解法-5"></a> 解法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int last,bool lim,bool qd,bool sh)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][last][qd][sh]!=-1)return f[len][last][qd][sh];</span><br><span class="line">    if(len==0)return 1;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(sh&amp;&amp;i&lt;last)continue;</span><br><span class="line">        res+=dfs(len-1,i,lim&amp;&amp;(i==up),qd&amp;&amp;(i==0),sh||((!sh)&amp;&amp;(!qd)&amp;&amp;(i&gt;last)));</span><br><span class="line">        res%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][last][qd][sh]=res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cf628d-magic-numbers"><a class="markdownIt-Anchor" href="#cf628d-magic-numbers"></a> <a href="http://codeforces.com/problemset/problem/628/D">CF628D Magic Numbers</a></h2><h3 id="题干-6"><a class="markdownIt-Anchor" href="#题干-6"></a> 题干</h3><p><em><strong>给你 4 个数 m,d,l,r保证 l,r位数相同。</strong></em><br /><em><strong>问满足以下条件的数 x 的个数：</strong></em><br /><em><strong>l≤x≤r x 的偶数位是 d，奇数位不是 d。 （这里定义偶数位为从高位往低位的数的偶数位）</strong></em><br /><em><strong>m∣x</strong></em><br /><em><strong>答案对 1000000007 取模。</strong></em><br /><em><strong>1≤m≤2000,0≤d≤9,1≤l≤r≤1e2000</strong></em></p><h3 id="解法-6"><a class="markdownIt-Anchor" href="#解法-6"></a> 解法</h3><p>由于l,r位数相同,我们可以强制让其没有前导0.(因为有前导0时,l,r的dfs的答案必定相同,相减为0,不需要统计)<br />我们还需额外判断 x=l 是否可行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int len,int qm,bool lim,bool qd,bool odd)&#123;</span><br><span class="line">    if(!lim&amp;&amp;f[len][qm][odd]!=-1)return f[len][qm][odd]%mod;</span><br><span class="line">    if(len==0)return qm==0;</span><br><span class="line">    int up=lim?a[len]:9;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=up;i++)&#123;</span><br><span class="line">        if(qd&amp;&amp;(i==0))continue;</span><br><span class="line">        if(odd&amp;&amp;i==d)continue;</span><br><span class="line">        if(!odd&amp;&amp;i!=d)continue;</span><br><span class="line">        res+=dfs(len-1,(qm*10+i)%m,lim&amp;&amp;(i==up),0,odd^1);res%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim)f[len][qm][odd]=res%mod;</span><br><span class="line">    return res%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2024/10/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorbrown-font-face仿宋背包问题fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorbrown-font-face仿宋背包问题fontcenter"></a> <center><font color="brown" font face="仿宋">背包问题</font></center></h1><p><a href="https://oi-wiki.org"> <font size = 5 font color = "red"> OI Wiki </font> </a></p><h2 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 01背包</h2><p>每个物品可以取1个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    for (int l = W; l &gt;= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h2><p>(每个物品可以取无数次)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int j=w[i];j&lt;=m;j++)</span><br><span class="line">        f[j]=max(f[j],f[j-w[i]]+d[i]);</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a class="markdownIt-Anchor" href="#多重背包"></a> 多重背包</h2><p>(每个物品可以取num[i]次)</p><h3 id="拆成01背包"><a class="markdownIt-Anchor" href="#拆成01背包"></a> 拆成01背包</h3><h3 id="二进制分组优化01背包"><a class="markdownIt-Anchor" href="#二进制分组优化01背包"></a> 二进制分组优化+01背包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int j=1;j&lt;=num[i];j&lt;&lt;=1)&#123;v2[++k]=v[i]*j;w2[k]=w[i]*j;num[i]-=j;&#125;</span><br><span class="line">    if(num[i])v2[++k]=num[i]*v[i],w2[k]=num[i]*w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列优化"><a class="markdownIt-Anchor" href="#单调队列优化"></a> 单调队列优化</h3><p>(待补充)</p><h2 id="混合背包"><a class="markdownIt-Anchor" href="#混合背包"></a> 混合背包</h2><p>(完全背包+多重背包)</p><h2 id="二维费用背包"><a class="markdownIt-Anchor" href="#二维费用背包"></a> 二维费用背包</h2><p>有 [n] 个任务需要完成，完成第 [i] 个任务需要花费 t[i] 分钟，产生 c[i] 元的开支。<br />现在有 [T] 分钟时间， [W] 元钱来处理这些任务，求最多能完成多少任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    for(int j=m;j&gt;=x;j--)</span><br><span class="line">        for(int k=t;k&gt;=y;k--)</span><br><span class="line">            dp[j][k]=max(dp[j-x][k-y]+1,dp[j][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包"><a class="markdownIt-Anchor" href="#分组背包"></a> 分组背包</h2><p><strong>有 [n] 件物品和一个大小为 [m] 的背包，第 [i] 个物品的价值为 w[i]，体积为 v[i].</strong><br /><strong>同时，每个物品属于一个组，同组内最多只能选择一个物品。求背包能装载物品的最大总价值.</strong><br />其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int k = 1; k &lt;= ts; k++)          // 循环每一组</span><br><span class="line">  for (int i = m; i &gt;= 0; i--)         // 循环背包容量</span><br><span class="line">    for (int j = 1; j &lt;= cnt[k]; j++)  // 循环该组的每一个物品</span><br><span class="line">      if (i &gt;= w[t[k][j]])             // 背包容量充足</span><br><span class="line">        dp[i] = max(dp[i],</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移</span><br></pre></td></tr></table></figure><p>这里要注意：一定不能搞错循环顺序，这样才能保证正确性。</p><h2 id="有依赖的背包"><a class="markdownIt-Anchor" href="#有依赖的背包"></a> 有依赖的背包</h2><h3 id="p1064-noip2006-提高组-金明的预算方案"><a class="markdownIt-Anchor" href="#p1064-noip2006-提高组-金明的预算方案"></a> <em><strong><a href="https://www.luogu.com.cn/problem/P1064"> P1064 [NOIP2006 提高组] 金明的预算方案 </a></strong></em></h3><p><strong>金明有 [n] 元钱，想要买 [m] 个物品，第 [i] 件物品的价格为 v[i] ，重要度为 p[i] 。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。</strong><br />*<em>目标是让所有购买的物品的 v[i]<em>p[i] 之和最大。</em></em><br />解法:考虑分类讨论。对于一个主件和它的若干附件，有以下几种可能：只买主件，买主件 + 某些附件。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p><p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p><h3 id="p3961-tjoi2013-黄金矿工"><a class="markdownIt-Anchor" href="#p3961-tjoi2013-黄金矿工"></a> <em><strong><a href="https://www.luogu.com.cn/problem/P3961"> P3961 [TJOI2013] 黄金矿工 </a></strong></em></h3><p>题目描述<br />小 A 最近迷上了在上课时玩《黄金矿工》这款游戏。为了避免被老师发现，他必须小心翼翼，因此他总是输。<br />在输掉自己所有的金币后，他向你求助。每个黄金可以看做一个点（没有体积）。现在给出你 N 个黄金的坐标，挖到它们所需要的时间以及它们的价值。有些黄金在同一条直线上，这时候你必须按顺序挖。你可以瞬间把钩子转到任意角度。<br />小 A 一开始在坐标 (0,0)，请你帮助小 A 算出在时间 T 内他最多可以得到多少价值的金子。<br />范围: N(200) T(4e4)</p><h2 id="背包练习"><a class="markdownIt-Anchor" href="#背包练习"></a> 背包练习</h2><h3 id="p1450-haoi2008-硬币购物"><a class="markdownIt-Anchor" href="#p1450-haoi2008-硬币购物"></a> <a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008] 硬币购物</a></h3><p><em><strong>背包+容斥</strong></em><br />先考虑没有个数限制的情况,f[i]表示没有限制的方案数;<br />答案为f[s]-不合法的情况;<br />考虑一种硬币超过限制时的方案数为f[s-(次硬币的总数+1)*此硬币的价值];<br />然后有重复,考虑对不合法的情况进行容斥.</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单算法模板总结</title>
      <link href="/2024/10/07/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/07/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋简单算法模板总结fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋简单算法模板总结fontcenter"></a> <center><font color="red" font face="仿宋">简单算法模板总结</font></center></h1><h2 id="快速幂"><a class="markdownIt-Anchor" href="#快速幂"></a> 快速幂</h2><p><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fp(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res*=a,res%=mod;</span><br><span class="line">        a*=a;a%=mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h2><p><a href="https://www.luogu.com.cn/problem/P3370"> P3370 【模板】字符串哈希 </a><br /><em>自然溢出方法：利用unsigned long long 自然溢出,相当于自动对2^64−1取模</em><br /><em>必要时可以使用双 <strong>hash</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ull unsigned long long</span><br><span class="line">ull has(string s)&#123;</span><br><span class="line">    ull res=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        res=res*131+ull(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛素数"><a class="markdownIt-Anchor" href="#线性筛素数"></a> 线性筛素数</h2><p><a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a><br /><em>这个算法使用“某数×质数”去筛合数，一个合数一定会被它的最小质因数筛掉</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(!vis[i])pr[++cnt]=i;</span><br><span class="line">    for(int j=1;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=n;j++)&#123;</span><br><span class="line">        vis[i*pr[j]]=1;</span><br><span class="line">        if(i%pr[j]==0)break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2><p><a href="https://www.luogu.com.cn/problem/B3644"> B3644 【模板】拓扑排序 / 家谱树 </a></p><ol><li>拓扑实现的步骤</li></ol><ul><li>计算每个点的入度。</li><li>入度为 0 就加入队列。</li><li>当队列不为空则循环：<ul><li>取出队首元素并输出</li><li>遍历队首元素的连边，对应节点的入度 −1</li><li>当对应的节点入度为 0 就加入队列</li></ul></li></ul><ol start="2"><li>代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)if(!rd[i])q.push(i);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int v : ed[u])&#123;</span><br><span class="line">            rd[v]--;</span><br><span class="line">            if(!rd[v])q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="floyd"><a class="markdownIt-Anchor" href="#floyd"></a> Floyd</h2><p><a href="https://www.luogu.com.cn/problem/B3647"> B3647 【模板】Floyd </a><br /><a href="https://www.luogu.com.cn/problem/B3611"> B3611 【模板】传递闭包 </a><br />O(n^3)求最短路,传递闭包<br /><em>传递闭包定义如下</em><br /><img src="https://pic.imgdb.cn/item/6703c3b4d29ded1a8c6fd9a0.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=min(f[i][k]+f[k][j],f[i][j]);</span><br><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(!f[i][j])f[i][j]=f[i][k]&amp;f[k][j];</span><br></pre></td></tr></table></figure><h2 id="判断负环"><a class="markdownIt-Anchor" href="#判断负环"></a> 判断负环</h2><p><a href="https://www.luogu.com.cn/problem/P3385"> P3385 【模板】负环 </a><br />spfa判负环<br />(可以松弛就松弛,松弛后如果没进队就进队)<br />如果一个点进队超过n次,则出现负环.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool spfa(int x)&#123;</span><br><span class="line">    while(!q.empty())q.pop();</span><br><span class="line">    q.push(x);inq[x]++;vis[x]=1;dis[x]=0;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();vis[u]=0;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v]=1;q.push(v);inq[v]++;</span><br><span class="line">                    if(inq[v]&gt;n)return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单源最短路"><a class="markdownIt-Anchor" href="#单源最短路"></a> 单源最短路</h2><p><a href="https://www.luogu.com.cn/problem/P4779"> P4779 【模板】单源最短路径（标准版）</a><br /><a href="https://www.zhihu.com/question/292283275">***<font color = "red">SPFA已死</font>***</a></p><p><em><strong>堆优dijkstra</strong></em><br /><em>priority_queue默认是大根堆,可以重载小于号</em><br />(两个集合:一个是已确定的最优集合,另一个为它的补集,每次从补集中选最优的加入前面的集合)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int v,w;</span><br><span class="line">    friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line">        return a.w&gt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">vector&lt;node&gt;ed[MN];</span><br><span class="line">void dij(int s)&#123;</span><br><span class="line">    dis[s]=0;q.push((node)&#123;s,dis[s]&#125;);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.top().v;q.pop();</span><br><span class="line">        if(vis[u])continue; //this line is very important</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(vis[v])continue;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.push((node)&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2><p>维护区间大小已知的多个区间最值(线性复杂度)<br />用双端队列维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    while(!q.empty()&amp;&amp;q.front()&lt;=i-k)q.pop_front();</span><br><span class="line">    while(!q.empty()&amp;&amp;a[q.back()]&gt;=a[i])q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    b1[i]=a[q.front()];</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())q.pop_back();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    while(!q.empty()&amp;&amp;q.front()&lt;=i-k)q.pop_front();</span><br><span class="line">    while(!q.empty()&amp;&amp;a[q.back()]&lt;=a[i])q.pop_back();</span><br><span class="line">    q.push_back(i);</span><br><span class="line">    b2[i]=a[q.front()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2><p>找到左或右第一个大于(小于)此元素的下标(线性复杂度)<br />用栈维护<br />下面以找到右面第一个大于此元素的下标为例<br />如果不存在则下标默认为零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">    while(!ed.empty()&amp;&amp;a[ed.back()]&lt;=a[i])ed.pop_back();</span><br><span class="line">    if(!ed.empty())b[i]=ed.back();</span><br><span class="line">    ed.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> int find(int x)&#123;</span><br><span class="line">    if(x!=fa[x])&#123;</span><br><span class="line">        return fa[x]=find(fa[x]);//路径压缩</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void hb(int x,int y)&#123;</span><br><span class="line">    int fx=find(x);int fy=find(y);</span><br><span class="line">    if(fx!=fy)fa[fy]=fx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2><p><a href="https://www.luogu.com.cn/problem/P3366"> P3366 【模板】最小生成树 </a></p><p><em><strong>Kruskal：</strong></em><br />先把边按照权值进行排序，用贪心的思想优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool kls()&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u=ed[i].u;</span><br><span class="line">        int v=ed[i].v;</span><br><span class="line">        if(find(u)!=find(v))&#123;</span><br><span class="line">            hb(u,v);</span><br><span class="line">            cnt++;</span><br><span class="line">            ans+=ed[i].w;</span><br><span class="line">            if(cnt==n-1)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt&lt;n-1)return 0;</span><br><span class="line">    else return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树板子segment-tree"><a class="markdownIt-Anchor" href="#线段树板子segment-tree"></a> 线段树板子(segment-tree)</h2><ol><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a><br />区间加 区间求和</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l];return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        tag[ls]+=tag[u];</span><br><span class="line">        tag[rs]+=tag[u];</span><br><span class="line">        sum[ls]+=tag[u]*(mid-l+1);</span><br><span class="line">        sum[rs]+=tag[u]*(r-mid);</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=(r-l+1)*k;</span><br><span class="line">            tag[u]+=k;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)return sum[u];</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://www.luogu.com.cn/problem/P3373"> P3373 【模板】线段树 2 </a><br />区间加 区间乘 区间求和</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">        sum[u]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        sum[ls]*=multag[u];sum[ls]%=mod;</span><br><span class="line">        sum[rs]*=multag[u];sum[rs]%=mod;</span><br><span class="line">        sum[ls]+=addtag[u]*(mid-l+1);sum[ls]%=mod;</span><br><span class="line">        sum[rs]+=addtag[u]*(r-mid);sum[rs]%=mod;</span><br><span class="line">        multag[ls]*=multag[u];multag[ls]%=mod;</span><br><span class="line">        multag[rs]*=multag[u];multag[rs]%=mod;</span><br><span class="line">        addtag[ls]*=multag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]*=multag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[ls]+=addtag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]+=addtag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[u]=0;multag[u]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    void addupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=k*(r-l+1);sum[u]%=mod;</span><br><span class="line">            addtag[u]+=k;addtag[u]%=mod; </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)addupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)addupd(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void mulupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]*=k;sum[u]%=mod;</span><br><span class="line">            multag[u]*=k;multag[u]%=mod;</span><br><span class="line">            addtag[u]*=k;addtag[u]%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)mulupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)mulupd(rs,mid+1,r,xl,xr,k); </span><br><span class="line">        pushup(u);  </span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u];</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)&#123;res+=cx(ls,l,mid,xl,xr);res%=mod;&#125;</span><br><span class="line">        if(xr&gt;mid)&#123;res+=cx(rs,mid+1,r,xl,xr);res%=mod;&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure><h2 id="树链剖分重链剖分"><a class="markdownIt-Anchor" href="#树链剖分重链剖分"></a> 树链剖分(重链剖分)</h2><p>路径加 子树加 路径求和 子树求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">struct SMT&#123;</span><br><span class="line">    int sum[MN&lt;&lt;2],tag[MN&lt;&lt;2];</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=(sum[ls]+sum[rs])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=w[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        (sum[ls]+=tag[u]*(mid-l+1)%mod)%=mod;</span><br><span class="line">        (sum[rs]+=tag[u]*(r-mid)%mod)%=mod;</span><br><span class="line">        (tag[ls]+=tag[u])%=mod;</span><br><span class="line">        (tag[rs]+=tag[u])%=mod;</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            (sum[u]+=k*(r-l+1))%=mod;</span><br><span class="line">            (tag[u]+=k)%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">struct HPD&#123;</span><br><span class="line">    int top[MN],siz[MN],dep[MN],son[MN],id[MN],fa[MN],cnt=0;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        w[cnt]=a[u];</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpath(int x,int y,int k)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            T.update(1,1,n,id[top[x]],id[x],k);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        T.update(1,1,n,id[x],id[y],k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpath(int x,int y)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            res+=T.cx(1,1,n,id[top[x]],id[x]);res%=mod;</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        res+=T.cx(1,1,n,id[x],id[y]);res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpoint(int u,int k)&#123;</span><br><span class="line">        T.update(1,1,n,id[u],id[u]+siz[u]-1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpoint(int u)&#123;</span><br><span class="line">        return T.cx(1,1,n,id[u],id[u]+siz[u]-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure><h2 id="lca"><a class="markdownIt-Anchor" href="#lca"></a> LCA</h2><p>1.树剖LCA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct HPD&#123;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    int dep[MN],siz[MN],son[MN],id[MN],fa[MN],top[MN],cnt=0;</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int lca(int x,int y)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl 不全总结(acm竞赛)</title>
      <link href="/2024/10/02/stl%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/02/stl%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="centerfont-colorred-font-face仿宋stl不全总结fontcenter"><a class="markdownIt-Anchor" href="#centerfont-colorred-font-face仿宋stl不全总结fontcenter"></a> <center><font color="red" font face="仿宋">stl不全总结</font></center></h1><p><em><strong><font size=5 font color= "gree">不全总结,目前本蒟蒻常用到的,等待补充 </font></strong></em><br />参考<a href="https://wyqz.top/p/870124582.html#toc-heading-57">C++ STL 总结-基于算法竞赛（悠享版）</a> orz /bx</p><h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p><font color ="brown">动态数组</font></p><h3 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h3><ol><li>初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mark down 简单入门</title>
      <link href="/2024/10/02/markdown%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/02/markdown%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/">markdown 官方教程</a></p><h1 id="center-font-face仿宋-font-color-orange-mark-down-简单入门-fontcenter"><a class="markdownIt-Anchor" href="#center-font-face仿宋-font-color-orange-mark-down-简单入门-fontcenter"></a> <center> <font face="仿宋" font color = "orange"> mark down 简单入门 </font></center></h1><p><code>这里面是源码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &lt;center&gt; &lt;font face=&quot;仿宋&quot; font color = &quot;orange&quot;&gt; mark down 简单入门 &lt;/font&gt;&lt;/center&gt;</span><br><span class="line">(html)</span><br></pre></td></tr></table></figure><h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">最多可支持到六级标题</span><br></pre></td></tr></table></figure><h2 id="段落换行"><a class="markdownIt-Anchor" href="#段落换行"></a> 段落&amp;&amp;换行</h2><p>美人迈兮音尘阙，</p><p>隔千里兮共明月。</p><h2 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h2><p><em>恰似一江春水向东流</em><br /><strong>恰似一江春水向东流</strong><br /><em><strong>恰似一江春水向东流</strong></em><br /><mark>恰似一江春水向东流</mark><br /><u>恰似一江春水向东流</u><br /><s>恰似一江春水向东流</s><br />恰似一江春水向东流[^1]</p><hr /><hr /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体并加粗***</span><br><span class="line">==高亮==</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br><span class="line">~~删除线~~</span><br><span class="line">___分割线</span><br><span class="line">***分割线</span><br><span class="line">[^1]脚注</span><br></pre></td></tr></table></figure><h2 id="粘代码"><a class="markdownIt-Anchor" href="#粘代码"></a> 粘代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码内容在两行```之间</span><br></pre></td></tr></table></figure><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><ol><li>有序列表一</li><li>有序列表二<ul><li>无序列表</li></ul><ul><li>无序列表</li></ul></li><li>有序列表三<ol><li>有序列表三中的有序列表一</li><li>有序列表三中的有序列表二</li></ol></li><li>to de list<ul><li>[x] 吃饭</li><li>[ ] 睡觉</li><li>[ ] 玩游戏</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表一</span><br><span class="line">2. 有序列表二</span><br><span class="line">   - 无序列表</span><br><span class="line">   + 无序列表</span><br><span class="line">3. 有序列表三</span><br><span class="line">    1. 有序列表三中的有序列表一</span><br><span class="line">    2. 有序列表三中的有序列表二</span><br><span class="line">4. to de liset</span><br><span class="line">    - [x] 吃饭</span><br><span class="line">    - [ ] 睡觉</span><br><span class="line">    - [ ] 玩游戏</span><br></pre></td></tr></table></figure><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">height/cm</th><th style="text-align:right">weight/kg</th></tr></thead><tbody><tr><td style="text-align:left">xbb</td><td style="text-align:center">12312132132123132313231</td><td style="text-align:right">11111</td></tr><tr><td style="text-align:left">xzb</td><td style="text-align:center">6545645</td><td style="text-align:right">64564666666664646464564</td></tr><tr><td style="text-align:left">wwy</td><td style="text-align:center">48646464</td><td style="text-align:right">548845645456464</td></tr><tr><td style="text-align:left">people</td><td style="text-align:center">6445645645645645644</td><td style="text-align:right">45313123123123123</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|name| height/cm |weight/kg| //表头· </span><br><span class="line">|:---| :---: |---:| //分别表示居左 居中 居右 对齐</span><br><span class="line">|xbb|12312132132123132313231|11111|</span><br><span class="line">|xzb|6545645|64564666666664646464564|</span><br><span class="line">|wwy|48646464|548845645456464|</span><br><span class="line">|people|6445645645645645644|45313123123123123|</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="the-quarterly-results-look-great"><a class="markdownIt-Anchor" href="#the-quarterly-results-look-great"></a> The quarterly results look great!</h3><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br><span class="line">&gt; ### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><p><a href="https://www.bilibili.com/">bilibili</a><br /><a href="https://www.bilibili.com/" title="B站">bilibili</a><br /><a href="mailto:3156993539@qq.com">3156993539@qq.com</a><br />雪白白白子的 <em><strong><a href="https://megumi1101.github.io/">blog</a></strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bilibili](https://www.bilibili.com/)</span><br><span class="line">[bilibili](https://www.bilibili.com/ &quot;B站&quot;)</span><br><span class="line">&lt;3156993539@qq.com&gt;</span><br><span class="line">雪白白白子的 ***[blog](https://megumi1101.github.io/)***</span><br></pre></td></tr></table></figure><h2 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h2><p><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png)</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png" alt="image.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png&quot; alt=&quot;image.png&quot;&gt;</span><br><span class="line">(使用HTML语法)</span><br></pre></td></tr></table></figure><h2 id="写入latex公式katex"><a class="markdownIt-Anchor" href="#写入latex公式katex"></a> 写入latex公式(katex)</h2><ul><li>单行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x)=ax+b </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p><ul><li>多行</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\begin{Bmatrix}a&amp;b\\c&amp;d\end{Bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x)=ax+b $$</span><br><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">a&amp;b\\</span><br><span class="line">c&amp;d</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
