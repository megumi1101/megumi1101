<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简单模板总结</title>
      <link href="/2024/10/07/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/07/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="简单模板总结"><a href="#简单模板总结" class="headerlink" title="简单模板总结"></a><center><font color="red" font face="仿宋">简单模板总结</font></center></h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fp(int a,int b)&#123;</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res*=a,res%=mod;</span><br><span class="line">        a*=a;a%=mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p><a href="https://www.luogu.com.cn/problem/P3370"> P3370 【模板】字符串哈希 </a><br><em>自然溢出方法：利用unsigned long long 自然溢出,相当于自动对2^64−1取模</em><br><em>必要时可以使用双 <strong>hash</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ull unsigned long long</span><br><span class="line">ull has(string s)&#123;</span><br><span class="line">    ull res=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        res=res*131+ull(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛素数"><a href="#线性筛素数" class="headerlink" title="线性筛素数"></a>线性筛素数</h2><p> <a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a><br><em>这个算法使用“某数×质数”去筛合数，一个合数一定会被它的最小质因数筛掉</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(!vis[i])pr[++cnt]=i;</span><br><span class="line">    for(int j=1;j&lt;=cnt&amp;&amp;i*pr[j]&lt;=n;j++)&#123;</span><br><span class="line">        vis[i*pr[j]]=1;</span><br><span class="line">        if(i%pr[j]==0)break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>  <a href="https://www.luogu.com.cn/problem/B3644"> B3644 【模板】拓扑排序 &#x2F; 家谱树 </a></p><ol><li>拓扑实现的步骤</li></ol><ul><li>计算每个点的入度。</li><li>入度为 0 就加入队列。</li><li>当队列不为空则循环：<ul><li>取出队首元素并输出</li><li>遍历队首元素的连边，对应节点的入度 −1</li><li>当对应的节点入度为 0 就加入队列</li></ul></li></ul><ol start="2"><li>代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)if(!rd[i])q.push(i);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int v : ed[u])&#123;</span><br><span class="line">            rd[v]--;</span><br><span class="line">            if(!rd[v])q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p><a href="https://www.luogu.com.cn/problem/B3647"> B3647 【模板】Floyd </a><br><a href="https://www.luogu.com.cn/problem/B3611"> B3611 【模板】传递闭包 </a><br>O(n^3)求最短路,传递闭包<br><em>传递闭包定义如下</em><br><img src="https://pic.imgdb.cn/item/6703c3b4d29ded1a8c6fd9a0.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=min(f[i][k]+f[k][j],f[i][j]);</span><br><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(!f[i][j])f[i][j]=f[i][k]&amp;f[k][j];</span><br></pre></td></tr></table></figure><h2 id="判断负环"><a href="#判断负环" class="headerlink" title="判断负环"></a>判断负环</h2><p><a href="https://www.luogu.com.cn/problem/P3385"> P3385 【模板】负环 </a><br>spfa判负环<br>(可以松弛就松弛,松弛后如果没进队就进队)<br>如果一个点进队超过n次,则出现负环.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool spfa(int x)&#123;</span><br><span class="line">    while(!q.empty())q.pop();</span><br><span class="line">    q.push(x);inq[x]++;vis[x]=1;dis[x]=0;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();vis[u]=0;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v]=1;q.push(v);inq[v]++;</span><br><span class="line">                    if(inq[v]&gt;n)return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p><a href="https://www.luogu.com.cn/problem/P4779"> P4779 【模板】单源最短路径（标准版）</a><br><a href="https://www.zhihu.com/question/292283275"><em><strong><font color = "red">SPFA已死</font></strong></em></a></p><p><em><strong>堆优dijkstra</strong></em><br><em>priority_queue默认是大根堆,可以重载小于号</em><br>(两个集合:一个是已确定的最优集合,另一个为它的补集,每次从补集中选最优的加入前面的集合)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int v,w;</span><br><span class="line">    friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line">        return a.w&gt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">vector&lt;node&gt;ed[MN];</span><br><span class="line">void dij(int s)&#123;</span><br><span class="line">    dis[s]=0;q.push((node)&#123;s,dis[s]&#125;);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.top().v;q.pop();</span><br><span class="line">        if(vis[u])continue; //this line is very important</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=0;i&lt;ed[u].size();i++)&#123;</span><br><span class="line">            int v=ed[u][i].v;</span><br><span class="line">            int w=ed[u][i].w;</span><br><span class="line">            if(vis[v])continue;</span><br><span class="line">            if(dis[u]+w&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.push((node)&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p> <a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> int find(int x)&#123;</span><br><span class="line">    if(x!=fa[x])&#123;</span><br><span class="line">        return fa[x]=find(fa[x]);//路径压缩</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void hb(int x,int y)&#123;</span><br><span class="line">    int fx=find(x);int fy=find(y);</span><br><span class="line">    if(fx!=fy)fa[fy]=fx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p> <a href="https://www.luogu.com.cn/problem/P3366"> P3366 【模板】最小生成树 </a></p><p> <em><strong>Kruskal：</strong></em><br> 先把边按照权值进行排序，用贪心的思想优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool kls()&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u=ed[i].u;</span><br><span class="line">        int v=ed[i].v;</span><br><span class="line">        if(find(u)!=find(v))&#123;</span><br><span class="line">            hb(u,v);</span><br><span class="line">            cnt++;</span><br><span class="line">            ans+=ed[i].w;</span><br><span class="line">            if(cnt==n-1)break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt&lt;n-1)return 0;</span><br><span class="line">    else return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线段树板子-segment-tree"><a href="#线段树板子-segment-tree" class="headerlink" title="线段树板子(segment-tree)"></a>线段树板子(segment-tree)</h2><ol><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a><br>区间加 区间求和<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l];return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        tag[ls]+=tag[u];</span><br><span class="line">        tag[rs]+=tag[u];</span><br><span class="line">        sum[ls]+=tag[u]*(mid-l+1);</span><br><span class="line">        sum[rs]+=tag[u]*(r-mid);</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=(r-l+1)*k;</span><br><span class="line">            tag[u]+=k;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(l&gt;=xl&amp;&amp;r&lt;=xr)return sum[u];</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure></li><li><a href="https://www.luogu.com.cn/problem/P3373"> P3373 【模板】线段树 2 </a><br>区间加 区间乘 区间求和<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">struct smt&#123;</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=sum[ls]+sum[rs];</span><br><span class="line">        sum[u]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=a[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        sum[ls]*=multag[u];sum[ls]%=mod;</span><br><span class="line">        sum[rs]*=multag[u];sum[rs]%=mod;</span><br><span class="line">        sum[ls]+=addtag[u]*(mid-l+1);sum[ls]%=mod;</span><br><span class="line">        sum[rs]+=addtag[u]*(r-mid);sum[rs]%=mod;</span><br><span class="line">        multag[ls]*=multag[u];multag[ls]%=mod;</span><br><span class="line">        multag[rs]*=multag[u];multag[rs]%=mod;</span><br><span class="line">        addtag[ls]*=multag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]*=multag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[ls]+=addtag[u];addtag[ls]%=mod;</span><br><span class="line">        addtag[rs]+=addtag[u];addtag[rs]%=mod;</span><br><span class="line">        addtag[u]=0;multag[u]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    void addupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]+=k*(r-l+1);sum[u]%=mod;</span><br><span class="line">            addtag[u]+=k;addtag[u]%=mod; </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)addupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)addupd(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void mulupd(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            sum[u]*=k;sum[u]%=mod;</span><br><span class="line">            multag[u]*=k;multag[u]%=mod;</span><br><span class="line">            addtag[u]*=k;addtag[u]%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)mulupd(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)mulupd(rs,mid+1,r,xl,xr,k); </span><br><span class="line">        pushup(u);  </span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u];</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)&#123;res+=cx(ls,l,mid,xl,xr);res%=mod;&#125;</span><br><span class="line">        if(xr&gt;mid)&#123;res+=cx(rs,mid+1,r,xl,xr);res%=mod;&#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br></pre></td></tr></table></figure></li></ol><h2 id="树链剖分-重链剖分"><a href="#树链剖分-重链剖分" class="headerlink" title="树链剖分(重链剖分)"></a>树链剖分(重链剖分)</h2><p>路径加 子树加 路径求和 子树求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">struct SMT&#123;</span><br><span class="line">    int sum[MN&lt;&lt;2],tag[MN&lt;&lt;2];</span><br><span class="line">    #define ls (u&lt;&lt;1)</span><br><span class="line">    #define rs (u&lt;&lt;1|1)</span><br><span class="line">    #define mid ((l+r)&gt;&gt;1)</span><br><span class="line">    void pushup(int u)&#123;</span><br><span class="line">        sum[u]=(sum[ls]+sum[rs])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    void build(int u,int l,int r)&#123;</span><br><span class="line">        if(l==r)&#123;sum[u]=w[l]%mod;return;&#125;</span><br><span class="line">        build(ls,l,mid);</span><br><span class="line">        build(rs,mid+1,r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    void pushdown(int u,int l,int r)&#123;</span><br><span class="line">        (sum[ls]+=tag[u]*(mid-l+1)%mod)%=mod;</span><br><span class="line">        (sum[rs]+=tag[u]*(r-mid)%mod)%=mod;</span><br><span class="line">        (tag[ls]+=tag[u])%=mod;</span><br><span class="line">        (tag[rs]+=tag[u])%=mod;</span><br><span class="line">        tag[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int u,int l,int r,int xl,int xr,int k)&#123;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            (sum[u]+=k*(r-l+1))%=mod;</span><br><span class="line">            (tag[u]+=k)%=mod;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)update(ls,l,mid,xl,xr,k);</span><br><span class="line">        if(xr&gt;mid)update(rs,mid+1,r,xl,xr,k);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    int cx(int u,int l,int r,int xl,int xr)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        if(xl&lt;=l&amp;&amp;r&lt;=xr)&#123;</span><br><span class="line">            return sum[u]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u,l,r);</span><br><span class="line">        if(xl&lt;=mid)res+=cx(ls,l,mid,xl,xr);</span><br><span class="line">        if(xr&gt;mid)res+=cx(rs,mid+1,r,xl,xr);</span><br><span class="line">        res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">struct HPD&#123;</span><br><span class="line">    int top[MN],siz[MN],dep[MN],son[MN],id[MN],fa[MN],cnt=0;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        w[cnt]=a[u];</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpath(int x,int y,int k)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            T.update(1,1,n,id[top[x]],id[x],k);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        T.update(1,1,n,id[x],id[y],k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpath(int x,int y)&#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            res+=T.cx(1,1,n,id[top[x]],id[x]);res%=mod;</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        res+=T.cx(1,1,n,id[x],id[y]);res%=mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void addpoint(int u,int k)&#123;</span><br><span class="line">        T.update(1,1,n,id[u],id[u]+siz[u]-1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    int cxpoint(int u)&#123;</span><br><span class="line">        return T.cx(1,1,n,id[u],id[u]+siz[u]-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><p>1.树剖LCA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct HPD&#123;</span><br><span class="line">    vector&lt;int&gt;ed[MN];</span><br><span class="line">    int dep[MN],siz[MN],son[MN],id[MN],fa[MN],top[MN],cnt=0;</span><br><span class="line">    void dfs1(int u,int f,int deep)&#123;</span><br><span class="line">        fa[u]=f;</span><br><span class="line">        siz[u]=1;</span><br><span class="line">        dep[u]=deep;</span><br><span class="line">        int maxson=-1;</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==f)continue;</span><br><span class="line">            dfs1(v,u,deep+1);</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            if(siz[v]&gt;maxson)&#123;</span><br><span class="line">                maxson=siz[v];</span><br><span class="line">                son[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs2(int u,int topfa)&#123;</span><br><span class="line">        id[u]=++cnt;</span><br><span class="line">        top[u]=topfa;</span><br><span class="line">        if(!son[u])return;</span><br><span class="line">        dfs2(son[u],topfa);</span><br><span class="line">        for(auto v:ed[u])&#123;</span><br><span class="line">            if(v==fa[u]||v==son[u])continue;</span><br><span class="line">            dfs2(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int lca(int x,int y)&#123;</span><br><span class="line">        while(top[x]!=top[y])&#123;</span><br><span class="line">            if(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        if(dep[x]&gt;dep[y])swap(x,y);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl 不全总结(acm竞赛)</title>
      <link href="/2024/10/02/stl%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/02/stl%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="stl不全总结"><a href="#stl不全总结" class="headerlink" title="stl不全总结"></a><center><font color="red" font face="仿宋">stl不全总结</font></center></h1><p><em><strong><font size=5 font color= "gree">不全总结,目前本蒟蒻常用到的,等待补充 </font></strong></em><br>参考<a href="https://wyqz.top/p/870124582.html#toc-heading-57">C++ STL 总结-基于算法竞赛（悠享版）</a> orz &#x2F;bx </p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><font color ="brown">动态数组</font></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>初始化</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mark down 简单入门</title>
      <link href="/2024/10/02/markdown%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/02/markdown%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/">markdown 官方教程</a></p><h1 id="mark-down-简单入门"><a href="#mark-down-简单入门" class="headerlink" title="  mark down 简单入门 "></a><center> <font face="仿宋" font color = "orange"> mark down 简单入门 </font></center></h1><p><code>这里面是源码</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &lt;center&gt; &lt;font face=&quot;仿宋&quot; font color = &quot;orange&quot;&gt; mark down 简单入门 &lt;/font&gt;&lt;/center&gt;</span><br><span class="line">(html)</span><br></pre></td></tr></table></figure><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">最多可支持到六级标题</span><br></pre></td></tr></table></figure><h2 id="段落-换行"><a href="#段落-换行" class="headerlink" title="段落&amp;&amp;换行"></a>段落&amp;&amp;换行</h2><p>美人迈兮音尘阙，</p><p>隔千里兮共明月。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><em>恰似一江春水向东流</em><br><strong>恰似一江春水向东流</strong><br><em><strong>恰似一江春水向东流</strong></em><br>&#x3D;&#x3D;恰似一江春水向东流&#x3D;&#x3D;<br><u>恰似一江春水向东流</u><br><del>恰似一江春水向东流</del><br>恰似一江春水向东流[^1]</p><hr><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**加粗**</span><br><span class="line">***斜体并加粗***</span><br><span class="line">==高亮==</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br><span class="line">~~删除线~~</span><br><span class="line">___分割线</span><br><span class="line">***分割线</span><br><span class="line">[^1]脚注</span><br></pre></td></tr></table></figure><h2 id="粘代码"><a href="#粘代码" class="headerlink" title="粘代码"></a>粘代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码内容在两行```之间</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>有序列表一</li><li>有序列表二<ul><li>无序列表</li></ul><ul><li>无序列表</li></ul></li><li>有序列表三<ol><li>有序列表三中的有序列表一</li><li>有序列表三中的有序列表二</li></ol></li><li>to de list<ul><li><input checked="" disabled="" type="checkbox"> 吃饭</li><li><input disabled="" type="checkbox"> 睡觉</li><li><input disabled="" type="checkbox"> 玩游戏</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表一</span><br><span class="line">2. 有序列表二</span><br><span class="line">   - 无序列表</span><br><span class="line">   + 无序列表</span><br><span class="line">3. 有序列表三</span><br><span class="line">    1. 有序列表三中的有序列表一</span><br><span class="line">    2. 有序列表三中的有序列表二</span><br><span class="line">4. to de liset</span><br><span class="line">    - [x] 吃饭</span><br><span class="line">    - [ ] 睡觉</span><br><span class="line">    - [ ] 玩游戏</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="left">name</th><th align="center">height&#x2F;cm</th><th align="right">weight&#x2F;kg</th></tr></thead><tbody><tr><td align="left">xbb</td><td align="center">12312132132123132313231</td><td align="right">11111</td></tr><tr><td align="left">xzb</td><td align="center">6545645</td><td align="right">64564666666664646464564</td></tr><tr><td align="left">wwy</td><td align="center">48646464</td><td align="right">548845645456464</td></tr><tr><td align="left">people</td><td align="center">6445645645645645644</td><td align="right">45313123123123123</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|name| height/cm |weight/kg| //表头· </span><br><span class="line">|:---| :---: |---:| //分别表示居左 居中 居右 对齐</span><br><span class="line">|xbb|12312132132123132313231|11111|</span><br><span class="line">|xzb|6545645|64564666666664646464564|</span><br><span class="line">|wwy|48646464|548845645456464|</span><br><span class="line">|people|6445645645645645644|45313123123123123|</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h3><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br><span class="line">&gt; ### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.bilibili.com/">bilibili</a><br><a href="https://www.bilibili.com/" title="B站">bilibili</a><br><a href="mailto:&#51;&#49;&#x35;&#54;&#57;&#x39;&#51;&#x35;&#x33;&#x39;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#51;&#49;&#x35;&#54;&#57;&#x39;&#51;&#x35;&#x33;&#x39;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a><br>雪白白白子的 <em><strong><a href="https://megumi1101.github.io/">blog</a></strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bilibili](https://www.bilibili.com/)</span><br><span class="line">[bilibili](https://www.bilibili.com/ &quot;B站&quot;)</span><br><span class="line">&lt;3156993539@qq.com&gt;</span><br><span class="line">雪白白白子的 ***[blog](https://megumi1101.github.io/)***</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png)</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png" alt="image.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://pic.imgdb.cn/item/66fe7a5a335a200d6a9cdb16.png&quot; alt=&quot;image.png&quot;&gt;</span><br><span class="line">(使用HTML语法)</span><br></pre></td></tr></table></figure><h2 id="写入latex公式"><a href="#写入latex公式" class="headerlink" title="写入latex公式"></a>写入latex公式</h2><ul><li>单行<br>$ f(x)&#x3D;ax+b $</li><li>多行<br>$$<br>\begin{Bmatrix}<br>a&amp;b\<br>c&amp;d<br>\end{Bmatrix}<br>$$</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ f(x)=ax+b $</span><br><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">a&amp;b\\</span><br><span class="line">c&amp;d</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
